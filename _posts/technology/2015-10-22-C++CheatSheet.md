---
title: C++ Cheat Sheet  
date: 2015-10-22 17:30  
layout: post
category: technology
---  
记录一些容易忘记或记忆不清的C++基础知识：  

* 在类内部定义的函数默认为inline，inline关键字在声明和定义处指明都是合法的，inline函数应定义在头文件中。优点：省去函数调用的开销；缺点：代码膨胀。

* malloc，free与new，delete的区别？  
malloc，free是C中的库函数，而new，delete是C++中的操作符；new能自动识别所创建对象需要的内存大小，并能自动调用类的默认构造函数，而malloc必须显式指明需要分配的内存大小。

* 深拷贝与浅拷贝：  
浅拷贝是位拷贝，当有指针时只拷贝指针地址，深拷贝是值拷贝，当有指针时会重新分配内存。

* C++会提供的默认函数：默认构造函数，析构函数，拷贝构造函数，赋值函数。
* 定义一个对象并用同类型的一个对象对其进行初始化时，显示调用拷贝构造函数；当将该类型的对象传递到函数或从函数返回该类型对象时隐式调用拷贝构造函数。

* C++ static 成员变量，成员函数：只在类定义中声明，在类定义外定义，static关键字只在声明时使用。
* C++const成员变量：只能在类的构造函数初始化列表中初始化。
* C++const成员函数：const关键字加在形参列表之后，const必须同时出现在声明与定义中。

* 基于成员函数是否为const可以重载一个成员函数，同样的，基于一个指针形参是否指向const，可以重载一个函数。
* 形参为引用或指针时，可以通过是否为const重载函数，不能通过指针本身是否为const重载，而是其指向是否为const。

* 前置声明：可以在一定程度上解决类定义循环依赖问题；前置声明的类只能用于指针、引用、函数形参、返回值，不能实例化。

* 不能从const成员函数返回指向类对象的普通引用，const成员函数只能返回*this作为一个const引用。

* mutable成员不能为const，const成员函数也可以改变mutable成员的值。

* 前置递增（+1后直接返回）比后置递增（先备份，再+1，再返回备份）效率高。

* 抽象类与接口的关系？  
抽象类与借口都不能实例化，抽象类的子类或者接口的实现类需要实现其中的函数；  
继承抽象类是（is-a）的关系，而实现借口是满足一系列行为规范；  
接口中不能包含数据成员；  
接口可以用于支持回调而抽象类不行；

* 什么时候需要将类的析构函数定义为虚拟的？  
当类需要继承时，为了让指向子类的指针能够delete，需要将父类的析构函数定义为虚拟的。

* 虚函数的实现机制：通过虚表和虚指针实现。  
两种多态机制实现：1. 按照绝对位置查找（虚函数），编译时做好索引，运行速度快，缺点：子类继承只重写少量虚函数的话浪费内存；2. 按函数名称查找，时间效率不高。

* C++中不能重载的操作符：  
.  (成员访问运算符)  
.*  (成员指针访问运算符)  
::  (域运算符)  
sizeof  (长度运算符)  
?:  (条件运算符）

* C++中不能声明为虚函数的函数：  
普通函数，构造函数，静态成员函数，内联成员函数，友元函数。

* 虚基类：继承时加上virtual关键字，保证多个相同间接基类的成员变量只有一份（需要在虚基类每个子类继承时加上关键字，并手动初始化基类）。

* 类的static成员也会被继承，并共用空间。

* 静态成员存放在静态区，不占用类的内存，另外计算内存需要注意字节对齐。

* 对任何const或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。  
成员在初始化式中的初始化次序就是定义成员的次序。  
一个类只要定义了一个构造函数，编译器就不提供默认构造函数了。

* 可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。  
可以将构造函数声明为explicit来防止在需要隐式转换的上下文中使用构造函数。（explicit只能用于类内部的构造函数声明上，定义时不再重复）

* 友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类，关键字friend只能出现在类定义的内部。

* 如果初始化式是一个常量表达式，整型const static数据成员就可以在类的定义体中进行初始化，但是还是需要在类的定义体之外进行定义。

* 为了防止复制，必须显示声明类的复制构造函数为private，如果连友元及成员中的复制也要禁止的话，可以声明一个private的复制构造函数而不定义。

* 撤销一个容器（标准库或内置数组）时，会运行容器中类类型元素的析构函数，容器中的元素总是按逆序撤销。  
合成析构函数按对象创建时的逆序来撤销每个非static成员，也就是按成员在类中的声明次序的逆序撤销成员。  
即使定义了析构函数，也还会运行合成析构函数（在定义的析构函数之后执行）。

* rule of three：如果需要析构函数，则也需要赋值操作符和复制构造函数。

* 重载操作符必须具有至少一个类类型或枚举类型的操作数。这条规则强制重载操作符不能重新定义用于内置类型对象的操作符的含义。  
重载有内置含义的操作符如逗号、取地址、逻辑与、逻辑或等就不能再使用这些内置含义（如：逻辑操作符不再短路）。

* 赋值（=）、下标（[ ]）、调用（( )）和成员访问箭头（->）等操作符必须定义为成员；复合赋值操作符应定义为类的成员，但不是必须的；改变对象状态或与给定类型紧密联系的一些操作符如自增、自减和解引用，通常应定义为成员；对称的操作符如算术操作符、相等操作符、关系操作符和位操作符最好定义为非成员函数。

* 输出操作符应输出对象的内容，进行最小限度的格式化。

* 定义自增自减操作符的前缀形式和后缀形式：后缀操作符函数接受一个额外的（无用的）int型形参。

* 转换函数的通用形式：operator type( ); type表示内置类型名、类类型名或由类型别名所定义的名字。转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空。

* 派生类重定义虚函数时，可以使用virtual保留字，但不是必须的。
在某些情况下，希望覆盖虚函数机制并强制函数调用使用虚函数的特定版本，可以使用作用域操作符。只有成员函数中的代码才应该使用作用域操作符覆盖虚函数机制。

* 友元关系不能继承，基类的友元对派生类的成员么有特殊访问权限。如果基类被授予友元关系，只有基类有特殊访问权限，派生类没有。

* 如果派生类显示定义自己的拷贝构造函数或赋值操作符，则该定义将完全覆盖默认定义。被继承类的复制构造函数和赋值操作符负责对基类成分以及类自己的成员进行复制或赋值。一般来说该拷贝构造函数应显示使用基类拷贝构造函数初始化对象的基类部分，赋值操作符也一样。

* 如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。

* 在派生类作用域中派生类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽。  
如果派生类重定义了重载函数，则通过派生类型只能访问派生类中重定义的那些成员。

* 派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用或指针的虚函数，派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。